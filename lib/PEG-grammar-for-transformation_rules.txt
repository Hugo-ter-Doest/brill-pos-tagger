{

  function next_tag_is(tagged_sentence, i) {

  }

  function next_word_is_cap(tagged_sentence, i) {

  }

  function prev_1_or_2_or_3_tag(tagged_sentence, i) {

  }

  function prev_1_or_2_tag(tagged_sentence, i) {

  }

  function next_word_is_tag(tagged_sentence, i) {

  }

  function prev_tag_is(tagged_sentence, i) {

  }

  function current_word_is_tag(tagged_sentence, i) {

  }

  function prev_word_is_cap(tagged_sentence, i) {
  
  }

  function current_word_is_cap(tagged_sentence, i) {
  
  }
  
  function default_transformation_rule(tagged_sentence, i) {
  
  }
  
  var predicates = {
    "NEXT-TAG": next_tag_is,
    "NEXT-WORD-IS-CAP": next_word_is_cap,
    "PREV-1-OR-2-OR-3-TAG": prev_1_or_2_or_3_tag,
    "PREV-1-OR-2-TAG": prev_1_or_2_tag,
    "NEXT-WORD-IS-TAG": next_word_is_tag,
    "PREV-TAG": prev_tag_is,
    "CURRENT-WORD-IS-TAG": current_word_is_tag,
    "PREV-WORD-IS-CAP": prev_word_is_cap,
    "CURRENT-WORD-IS-CAP": current_word_is_cap
  };

  function TransformationRule(c1, c2, predicate, parameter) {
    this.literal = [c1, c2, predicate, parameter];
    this.predicate = predicates[predicate];
    if (!this.predicate) {
      this.predicate = default_transformation_rule;
    }
    console.log("X" + predicate + "X");
    console.log(this.predicate);
    this.old_category = c1;
    this.new_category = c2;
  }

  TransformationRule.prototype.apply = function(tagged_sentence, position) {
    if (this.predicate(tagged_sentence, position)) {
      tagged_sentence[i][1] = this.new_category;
    }
  };
}

transformation_rules = rules: (S transformation_rule S) +
{
  var result = [];

  for (var i =0; i < rules.length; i++) {
    result.push(rules[i][1]);
  }
  return(result);
}

transformation_rule = c1: category S_no_eol c2: category S_no_eol pred: predicate S_no_eol par: parameter
{
  // Construct rule
  var result = new TransformationRule(c1, c2, pred, par);
  return(result);
}

category = identifier

predicate = identifier

parameter = identifier

identifier =
  characters: [\.a-zA-Z_0-9_-]+ S_no_eol
  {
   var s = "";
   for (var i = 0; i < characters.length; i++) {
     s += characters[i];
   }
   return(s);
  }

// Blanks
EOL =
  '\r\n' / '\n' / '\r'
Comment =
  "\/\/" (!EOL .)* (EOL/EOI)
S =
  (' ' / '\t' / EOL / Comment)*
S_no_eol =
  (' ' / '\t' / Comment)*
EOI= 
  !.