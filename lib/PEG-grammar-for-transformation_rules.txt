{
  function Predicate(name, parameter) {
    this.name = name;
    this.parameter = parameter;
  }

  Predicate.prototype.evaluate = function(tagged_sentence, i) {
    switch(this.name) {
      case "NEXT-TAG": {}
      case "NEXT-WORD-IS-CAP": {}
      case "PREV-1-OR-2-OR-3-TAG": {}
      case "PREV-1-OR-2-TAG": {}
      case "NEXT-WORD-IS-TAG": {}
      case "PREV-TAG": {}
      case "CURRENT-WORD-IS-TAG": {}
      default: {return(false);}
    }
  };
 
  function TransformationRule(c1, c2, predicate) {
    this.predicate = predicate;
    this.old_category = c1;
    this.new_category = c2;
  }

  TransformationRule.prototype.apply = function(tagged_sentence, position) {
    if (this.predicate.evaluate(tagged_sentence, position)) {
      tagged_sentence[i][1] = this.new_category;
    }
  };
}

transformation_rules = rules: (S transformation_rule S) +
{
  var result = [];

  for (var i =0; i < rules.length; i++) {
    result.push(rules[i][1]);
  }
  return(result);
}

transformation_rule = c1: category S_no_eol c2: category S_no_eol pred: predicate S_no_eol par: parameter
{
  // Construct predicate
  var predicate = new Predicate(pred, par);
  // Construct rule
  var result = new TransformationRule(c1, c2, predicate);
  return(result);
}

category = identifier

predicate = identifier

parameter = identifier

identifier =
  characters: [a-zA-Z_0-9_-]+ S_no_eol
  {
   var s = "";
   for (var i = 0; i < characters.length; i++) {
     s += characters[i];
   }
   return(s);
  }

// Blanks
EOL =
  '\r\n' / '\n' / '\r'
Comment =
  "\/\/" (!EOL .)* (EOL/EOI)
S =
  (' ' / '\t' / EOL / Comment)*
S_no_eol =
  (' ' / '\t' / Comment)*
EOI= 
  !.